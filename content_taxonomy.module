<?php

// $Id$

/**
 * @file
 * Defines a field type for referencing a taxonomy term.
 **/

/**
 * Implementation of hook_help().
 **/
function content_taxonomy_help($path, $arg) {
  switch ($path) {
     case 'admin/help#content_taxonomy':
       return '<p>'. t('Defines a CCK field type for referencing taxonomy terms. The fields are independent from vocabulary settings and can be configured through the CCK admin field pages. The Content Taxonomy Module provides different widget types, at the moment including Option Widgets (Radios / Checkboxes, Selects), Autocompletes, Tree). The widget modules have to be enabled separately.') .'</p>';
  }
}

/**
 * Implementation of hook_theme().
 */
function content_taxonomy_theme() {
  return array(
    'content_taxonomy_formatter_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'content_taxonomy_formatter_link' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implementation of hook_field_info().
 */
function content_taxonomy_field_info() {
  return array(
    'content_taxonomy' => array(
      'label' => t('Content Taxonomy Fields'),
      'description' => t('Stores terms for nodes in the database.'),
      'callbacks' => array(
        'tables' => CONTENT_CALLBACK_DEFAULT,
        'arguments' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of hook_field_settings().
 */
function content_taxonomy_field_settings($op, $field) {
  switch ($op) {
    case 'form':
      $form = array();
            
      $form['save_term_node'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Save values additionally to the core taxonomy system (into the \'term_node\' table).'),
        '#default_value' => is_numeric($field['save_term_node']) ? $field['save_term_node'] : 0,
        '#description' => t('If this option is set, saving of terms is additionally handled by the taxonomy module. So saved terms from Content Taxonomy fields will appear as any other terms saved by the core taxonomy module. Set this option if you are using any other taxonomy application, like tagadelic. Otherwise terms are only saved in the cck tables and can only be accessed via the node or a view'), 
      );
      
      $options_voc = array();
      foreach (taxonomy_get_vocabularies() as $voc) {
        $options_voc[$voc->vid] = $voc->name;
      }
      
      $form['vid'] = array(
        '#title' => t('Vocabulary'),
        '#type' => 'select',
        '#default_value' => is_numeric($field['vid']) ? $field['vid'] : 0,
        '#options' => $options_voc,
        '#description' => t('Terms of the selected vocabulary get exposed to the field'),
      );
      
      $form['hierarchical_vocabulary'] = array(
        '#type' => 'fieldset',
        '#title' => t('Advanced settings for hierarchical vocabularies'),
        '#collapsible' => TRUE,
      );
      
      $form['hierarchical_vocabulary']['tid'] = array(
        '#title' => t('Parent Term'),
        '#type' => 'select',
        '#default_value' => is_numeric($field['tid']) ? $field['tid'] : 0,
        '#options' => _content_taxonomy_get_all_terms(),
        '#description' => t('If any term is selected here, only child terms of the selected are going to be exposed the field. Otherwise the whole vocabulary selected above'),
      );

      $form['hierarchical_vocabulary']['depth'] = array(
        '#type' => 'textfield',
        '#title' => t('Depth of taxonomy tree'),
        '#default_value' => is_numeric($field['depth']) ? $field['depth'] : '',
        '#description' => t('By setting a numeric value, the depth of the hierarchy shown can be limited. Leave this field blank to show the whole hierarchy.'),
      );
      
      $form['advanced'] = array(
        '#type' => 'fieldset',
        '#title' => t('Advanced settings'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      );
      $form['advanced']['hide_taxonomy_fields'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Hide default taxonomy fields on the node form'),
        '#default_value' => is_numeric($field['hide_taxonomy_fields']) ? $field['hide_taxonomy_fields'] : 1,
        '#description' => t('If this option is set for at least one Content Taxonomy Field per Content Type, default fields from the core Taxonomy module get hidden.'),
      );
      
      return $form;   
    
    case 'save':
      return array('save_term_node', 'vid', 'tid', 'depth', 'hide_taxonomy_fields');
    
    case 'database columns':
      return array(
        'value' => array('type' => 'int', 'not null' => FALSE, 'sortable' => FALSE),
      );
    
    case 'views data':
      $data = content_views_field_views_data($field);
      $table_alias = content_views_tablename($field);

      // Swap the filter handler to the 'in' operator.
      $data[$table_alias][$field['field_name'] .'_value']['filter']['handler'] = 'views_handler_filter_many_to_one_content_taxonomy';
      return $data;
  }
}

/**
 * Implementation of hook_field().
 */
function content_taxonomy_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {      
    case 'presave':
      if ($field['save_term_node']) {
        global $_content_taxonomy_array_cleared;
        if (!is_array($_content_taxonomy_array_cleared) || !$_content_taxonomy_array_cleared[$node->nid]) {
          taxonomy_node_delete_revision($node);
          unset($node->taxonomy);
          $_content_taxonomy_array_cleared[$node->nid] = true;
        }
      
        foreach ($items as $key => $entry) {
          if ($entry['value']) {
            $node->taxonomy[$entry['value']] = $entry['value'];
          }
        }
      }
      break;
  }
}


/**
 * Implementation of hook_field_formatter_info().
 */
function content_taxonomy_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('As Text'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
    'link' => array(
      'label' => t('As Link'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}


/**
 * Theme function for 'default' text field formatter.
 */
function theme_content_taxonomy_formatter_default($element) {
  $term = taxonomy_get_term($element['#item']['value']);
  return check_plain($term->name);
}

/**
 * Theme function for 'link' text field formatter.
 */
function theme_content_taxonomy_formatter_link($element) {
  $term = taxonomy_get_term($element['#item']['value']);
  return l($term->name, taxonomy_term_path($term), array('rel' => 'tag', 'title' => $term->description));
}

/**
 * Implementation of hook_content_is_empty().
 */
function content_taxonomy_content_is_empty($item, $field) {
  if (empty($item['value']) || $item['value'] == 0) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Called by content_allowed_values to create the $options array for the content_taxonomy_options
 */
function content_taxonomy_allowed_values($field) {
  $options = array();
  
  //for opt groups call different function
  if ($field['widget']['group_tid']) {
    return content_taxonomy_allowed_values_groups($field);
  }
  
  $depth = (is_numeric($field['depth'])) ? $field['depth'] : NULL;

  $tree = taxonomy_get_tree($field['vid'], $field['tid'], -1, $depth);
  
  if (is_array($tree)) {
    foreach ($tree as $term) {
      if ($field['widget']['show_depth']) {
        $value = str_repeat(' - ', $term->depth) . $term->name;
      }
      else {
        $value = $term->name;
      }
      $options[$term->tid] = check_plain($value);
    }
  }
  if ((!$field['required'] && !$field['multiple']) || ($field['widget']['type'] == 'content_taxonomy_select' && !$field['multiple'])) {
    $options = array('' => theme('optionwidgets_none', $field)) + $options;
  }
  return $options;
}

/** 
 * Creating Opt Groups for content_taxonomy_options
 */
function content_taxonomy_allowed_values_groups($field) {
  $options = array();
  $parent = $field['tid'];
  $group_parent = $field['widget']['group_tid'];
  
  //if children in no group
  $default_terms = taxonomy_get_children($parent);
  foreach ($default_terms as $default_term) {
    $options[$default_term->tid] = check_plain($default_term->name);
  }
  
  foreach (taxonomy_get_children($group_parent) as $group) {
    foreach (taxonomy_get_children($group->tid) as $term) {
      $options[$group->name][$term->tid] = check_plain($term->name);
      unset($options[$term->tid]);
    }
  }

  return $options;
}

/**
 * Implementation of hook_token_list().
 */
function content_taxonomy_token_list($type = 'all') {
  if ($type == 'field' || $type == 'all') {
    $tokens = array();

    $tokens['content_taxonomy']['term']  = t('Name of top taxonomy term');
    $tokens['content_taxonomy']['tid']   = t('ID of top taxonomy term');
    $tokens['content_taxonomy']['terms']  = t('Names of all taxonomy terms separated by commas');
    $tokens['content_taxonomy']['tids']   = t('IDs of all taxonomy terms separated by commas');
    $tokens['content_taxonomy']['vocab'] = t('Name of terms vocabulary');
    $tokens['content_taxonomy']['vid']   = t('ID of terms vocabulary');

    return $tokens;
  }
}

/**
 * Implementation of hook_token_values().
 */
function content_taxonomy_token_values($type, $object = NULL) {
  if ($type == 'field') {
    $items = $object;
    $terms = array();
    $tids = array();
    
    foreach ($items as $item) {
      $tid = $item['value'];
      if ($tid) {
        $term = taxonomy_get_term($tid);
        $tids[] = $tid;
        $terms[] = check_plain($term->name);
        $vid = $term->vid;
      }
    }
    if ($vid) {
      $vocabulary = taxonomy_vocabulary_load($vid);
    }

    $tokens['terms'] = implode(', ', $terms);
    $tokens['tids']  = implode(', ', $tids);
    $tokens['term']  = $terms[0];
    $tokens['tid']   = $tids[0];
    $tokens['vocab'] = isset($vocabulary) ? $vocabulary->name : '';
    $tokens['vid']   = $vid;

    return $tokens;
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * hides the taxonomy form if there exists a content taxonomy field, which is set to 'hide default taxonomy fields'
 */
function content_taxonomy_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type']) && $form['type']['#value'] .'_node_form' == $form_id) {
    $info = _content_type_info();
    $content_type = $info['content types'][$form['type']['#value']];
    foreach ($content_type['fields'] as $field_name => $field) {
      if ($field['type'] == 'content_taxonomy' && $field['hide_taxonomy_fields']) {
        unset($form['taxonomy']);
        break;
      }
    }
  }
}

/**
 * Implementation of hook_taxonomy().
 */
function content_taxonomy_taxonomy($op, $type, $array = NULL) {
  //keep the database consistent when either a voc or a term is deleted
  //in case of voc: delete all associated fields and its data
  //in case of term: delete all its entries
  if ($op == 'delete') {
    $vid = $array['vid'];
    $needs_refresh = FALSE;
    foreach (content_taxonomy_fields() as $type_name => $ct_type) {
      foreach ($ct_type['fields'] as $field_name => $field) {
        if ($field['vid'] == $vid) {
          if ($type == 'vocabulary') {
            module_load_include('inc', 'content', 'includes/content.crud');
            content_field_instance_delete($field_name, $field['type_name']);
            $needs_refresh = TRUE;
            watchdog('content', 'Deleted field %field_name and its data.', array('%field_name' => $field_name));
          }
          else {
            $tid = $array['tid'];
            if ($tid) {
              $db_info = content_database_info($field);
              db_query('DELETE FROM {'. $db_info['table'] .'} WHERE '. $db_info['columns']['value']['column'] .' = %d', $tid);
              $needs_refresh = TRUE;
              watchdog('content', 'Entries with term id = %tid have been deleted out of %table for field %field_name.', array('%tid' => $tid, '%table' => $db_info['table'], '%field_name' => $field_name));
            }
          }
        }
      }
    }
    if ($needs_refresh) {
      content_clear_type_cache(TRUE);
    }
  }
}

/**
 * Helper function that returns all content taxonomy fields, nested in their content types
 */
function content_taxonomy_fields() {
  static $ct_fields;
  
  if (!is_array($ct_fields)) {
    $ct_fields = array();
    foreach (content_types() as $type_name => $type) {
      foreach ($type['fields'] as $field_name => $field) {
        if ($field['type'] == 'content_taxonomy') {
          $ct_fields[$type_name]['fields'][$field_name] = $field;
        }
      }
    }
  }
  return $ct_fields;
}


/** 
 * Helper functions that returns all terms group by their vocabulary
 *
 * needed for some settings forms
 */
function _content_taxonomy_get_all_terms() {
  static $options = array();
  if (!count($options)) {
    $options[0] = '---';
    foreach (taxonomy_get_vocabularies() as $voc) {
      foreach (taxonomy_get_tree($voc->vid) as $term) {
        $options[$voc->name][$term->tid] = str_repeat('- ', $term->depth) . $term->name;
      }
    } 
  }
  return $options;
}
