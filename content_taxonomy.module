<?php

// $Id$

/**
 * @file
 * Defines a field type for referencing a taxonomy term.
 **/

/**
 * Implementation of hook_help().
 **/
function content_taxonomy_help($path, $arg) {
  switch ($path) {
     case 'admin/help#content_taxonomy':
       return '<p>'. t('Defines a CCK field type for referencing taxonomy terms. The fields are independent from vocabulary settings and can be configured through the CCK admin field pages. The Content Taxonomy Module provides different widget types, at the moment including Option Widgets (Radios / Checkboxes, Selects), Autocompletes, Tree). The widget modules have to be enabled separately.') .'</p>';
  }
}

/**
 * Implementation of hook_theme().
 */
function content_taxonomy_theme() {
  return array(
    'content_taxonomy_formatter_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'content_taxonomy_formatter_link' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implementation of hook_field_info().
 */
function content_taxonomy_field_info() {
  return array(
    'content_taxonomy' => array(
      'label' => t('Content Taxonomy Fields'),
      'description' => t('Stores terms for nodes in the database.'),
      'callbacks' => array(
        'tables' => CONTENT_CALLBACK_DEFAULT,
        'arguments' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of hook_field_settings().
 */
function content_taxonomy_field_settings($op, $field) {
  switch ($op) {
    case 'form':
      $form = array();
            
      $form['save_term_node'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Save values additionally to the core taxonomy system (into the \'term_node\' table).'),
        '#default_value' => is_numeric($field['save_term_node']) ? $field['save_term_node'] : 0,
        '#description' => t('If this option is set, saving of terms is additionally handled by the taxonomy module. So saved terms from Content Taxonomy fields will appear as any other terms saved by the core taxonomy module. Set this option if you are using any other taxonomy application, like tagadelic. Otherwise terms are only saved in the cck tables and can only be accessed via the node or a view'), 
      );
      
      $options_term = array();
      $options_voc = array();
      $options_term[0] = '---';
      foreach (taxonomy_get_vocabularies() as $voc) {
        $options_voc[$voc->vid] = $voc->name;
        foreach (taxonomy_get_tree($voc->vid) as $term) {
          $options_term[$voc->name][$term->tid] = str_repeat('- ', $term->depth) . $term->name;
        }
      }
      
      $form['vid'] = array(
        '#title' => t('Vocabulary'),
        '#type' => 'select',
        '#default_value' => is_numeric($field['vid']) ? $field['vid'] : 0,
        '#options' => $options_voc,
        '#description' => t('Terms of the selected vocabulary get exposed to the field'),
      );
      
      $form['hierarchical_vocabulary'] = array(
        '#type' => 'fieldset',
        '#title' => t('Advanced settings for hierarchical vocabularies'),
        '#collapsible' => TRUE,
      );
      
      $form['hierarchical_vocabulary']['tid'] = array(
        '#title' => t('Parent Term'),
        '#type' => 'select',
        '#default_value' => is_numeric($field['tid']) ? $field['tid'] : 0,
        '#options' => $options_term,
        '#description' => t('If any term is selected here, only child terms of the selected are going to be exposed the field. Otherwise the whole vocabulary selected above'),
      );

      $form['hierarchical_vocabulary']['depth'] = array(
        '#type' => 'textfield',
        '#title' => t('Depth of taxonomy tree'),
        '#default_value' => is_numeric($field['depth']) ? $field['depth'] : '',
        '#description' => t('By setting a numeric value, the depth of the hierarchy shown can be limited. Leave this field blank to show the whole hierarchy.'),
      );
      
      $form['hierarchical_vocabulary']['show_depth'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Indent child terms with \' - \' signs'),
        '#default_value' => is_numeric($field['show_depth']) ? $field['show_depth'] : 1,
        '#description' => t('If this option is checked, the hierarchy gets visualized by indenting child terms, otherwise it\'s a flat list'),
      );
      
      $form['advanced'] = array(
        '#type' => 'fieldset',
        '#title' => t('Advanced settings'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      );
      $form['advanced']['hide_taxonomy_fields'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Hide default taxonomy fields on the node form'),
        '#default_value' => is_numeric($field['hide_taxonomy_fields']) ? $field['hide_taxonomy_fields'] : 1,
        '#description' => t('If this option is set for at least one Content Taxonomy Field per Content Type, default fields from the core Taxonomy module get hidden.'),
      );
      
      return $form;   
    
    case 'save':
      return array('save_term_node', 'vid', 'tid', 'depth', 'show_depth', 'hide_taxonomy_fields');
    
    case 'database columns':
      return array(
        'value' => array('type' => 'int', 'not null' => FALSE, 'sortable' => FALSE),
      );
  }
}

/**
 * Implementation of hook_field().
 */
function content_taxonomy_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {      
    case 'presave':
      if ($field['save_term_node']) {
        global $_content_taxonomy_array_cleared;
        if (!is_array($_content_taxonomy_array_cleared) || !$_content_taxonomy_array_cleared[$node->nid]) {
          taxonomy_node_delete_revision($node);
          unset($node->taxonomy);
          $_content_taxonomy_array_cleared[$node->nid] = true;
        }
      
        foreach ($items as $key => $entry) {
          if ($entry['value']) {
            $node->taxonomy[$entry['value']] = $entry['value'];
          }
        }
      }
      break;
  }
}


/**
 * Implementation of hook_field_formatter_info().
 */
function content_taxonomy_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('As Text'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
    'link' => array(
      'label' => t('As Link'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}


/**
 * Theme function for 'default' text field formatter.
 */
function theme_content_taxonomy_formatter_default($element) {
  $term = taxonomy_get_term($element['#item']['value']);
  return check_plain($term->name);
}

/**
 * Theme function for 'link' text field formatter.
 */
function theme_content_taxonomy_formatter_link($element) {
  $term = taxonomy_get_term($element['#item']['value']);
  return l($term->name, taxonomy_term_path($term), array('rel' => 'tag', 'title' => $term->description));
}

/**
 * Implementation of hook_content_is_empty().
 */
function content_taxonomy_content_is_empty($item, $field) {
  if (empty($item['value']) || $item['value'] == 0) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Called by content_allowed_values to create the $options array for the content_taxonomy_options
 */
function content_taxonomy_allowed_values($field) {
  $options = array();
  
  //for opt groups call different function
  if ($field['widget']['group_tid']) {
    return content_taxonomy_allowed_values_groups($field);
  }
  
  $depth = (is_numeric($field['depth'])) ? $field['depth'] : NULL;

  $tree = taxonomy_get_tree($field['vid'], $field['tid'], -1, $depth);
  
  if (is_array($tree)) {
    foreach ($tree as $term) {
      if ($field['show_depth']) {
        $value = str_repeat(' - ', $term->depth) . $term->name;
      }
      else {
        $value = $term->name;
      }
      $options[$term->tid] = check_plain($value);
    }
  }
  return $options;
}

/** 
 * Creating Opt Groups for content_taxonomy_options
 */
function content_taxonomy_allowed_values_groups($field) {
  $options = array();
  $parent = $field['tid'];
  $group_parent = $field['widget']['group_tid'];
  
  //if children in no group
  $default_terms = taxonomy_get_children($parent);
  foreach ($default_terms as $default_term) {
    $options[$default_term->tid] = $default_term->name;
  }
  
  foreach (taxonomy_get_children($group_parent) as $group) {
    foreach (taxonomy_get_children($group->tid) as $term) {
      $options[$group->name][$term->tid] = $term->name;
      unset($options[$term->tid]);
    }
  }

  return $options;
}

/**
 * Implementation of hook_token_list().
 */
function content_taxonomy_token_list($type = 'all') {
  if ($type == 'field' || $type == 'all') {
    $tokens = array();

    $tokens['content_taxonomy']['term']  = t('Name of top taxonomy term');
    $tokens['content_taxonomy']['tid']   = t('ID of top taxonomy term');
    $tokens['content_taxonomy']['terms']  = t('Names of all taxonomy terms separated by commas');
    $tokens['content_taxonomy']['tids']   = t('IDs of all taxonomy terms separated by commas');
    $tokens['content_taxonomy']['vocab'] = t('Name of terms vocabulary');
    $tokens['content_taxonomy']['vid']   = t('ID of terms vocabulary');

    return $tokens;
  }
}

/**
 * Implementation of hook_token_values().
 */
function content_taxonomy_token_values($type, $object = NULL) {
  if ($type == 'field') {
    $items = $object;
    $terms = array();
    $tids = array();
    
    foreach ($items as $item) {
      $tid = $item['value'];
      if ($tid) {
        $term = taxonomy_get_term($tid);
        $tids[] = $tid;
        $terms[] = check_plain($term->name);
        $vid = $term->vid;
      }
    }
    if ($vid) {
      $vocabulary = taxonomy_vocabulary_load($vid);
    }

    $tokens['terms'] = implode(', ', $terms);
    $tokens['tids']  = implode(', ', $tids);
    $tokens['term']  = $terms[0];
    $tokens['tid']   = $tids[0];
    $tokens['vocab'] = isset($vocabulary) ? $vocabulary->name : '';
    $tokens['vid']   = $vid;

    return $tokens;
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * hides the taxonomy form if there exists a content taxonomy field, which is set to 'hide default taxonomy fields'
 */
function content_taxonomy_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type']) && $form['type']['#value'] .'_node_form' == $form_id) {
    $info = _content_type_info();
    $content_type = $info['content types'][$form['type']['#value']];
    foreach ($content_type['fields'] as $field_name => $field) {
      if ($field['type'] == 'content_taxonomy' && $field['hide_taxonomy_fields']) {
        unset($form['taxonomy']);
        break;
      }
    }
  }
}
