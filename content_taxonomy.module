<?php

// $Id$

/**
 * @file
 * Defines a field type for referencing a taxonomy term.
 **/

/**
 * Implementation of hook_help().
 **/
function content_taxonomy_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Defines a field type for referencing a taxonomy term. <em>Note: Requires content.module.</em>');
  }
}

/**
 * Implementation of hook_theme().
 */
function content_taxonomy_theme() {
  return array(
    'content_taxonomy_formatter_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'content_taxonomy_formatter_link' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implementation of hook_field_info().
 */
function content_taxonomy_field_info() {
  return array(
    'content_taxonomy' => array(
      'label' => t('Content Taxonomy Fields'),
      'description' => t('Stores terms for nodes in the database.'),
      'callbacks' => array(
        'tables' => CONTENT_CALLBACK_DEFAULT,
        'arguments' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of hook_field_settings().
 */
function content_taxonomy_field_settings($op, $field) {
  switch ($op) {
    case 'form':
      $form = array();
            
      $form['save_term_node'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Save values additionally to the core taxonomy system (into the \'term_node\' table).'),
        '#default_value' => is_numeric($field['save_term_node']) ? $field['save_term_node'] : 0,
        '#description' => t('If this option is set, saving of terms is additionally handled by the taxonomy module. So saved terms from Content Taxonomy fields will appear as any other terms saved by the core taxonomy module. Set this option if you are using any other taxonomy application, like tagadelic. Otherwise terms are only saved in the cck tables and can only be accessed via the node or a view'), 
      );
      
      $form['vocabulary'] = array(
        '#type' => 'fieldset',
        '#title' => t('Specify terms to show'),
        '#collapsible' => TRUE,
      );
      
      $options_term = array();
      $options_voc = array();
      $options_term[0] = '---';
      foreach (taxonomy_get_vocabularies() as $voc) {
        $options_voc[$voc->vid] = $voc->name;
        foreach (taxonomy_get_tree($voc->vid) as $term) {
          $options_term[$voc->name][$term->tid] = str_repeat('- ', $term->depth) . $term->name;
        }
      }
      
      $form['vocabulary']['vid'] = array(
        '#title' => t('Vocabulary'),
        '#type' => 'select',
        '#default_value' => is_numeric($field['vid']) ? $field['vid'] : 0,
        '#options' => $options_voc,
      );
      
      $form['vocabulary']['tid'] = array(
        '#title' => t('Parent Term'),
        '#type' => 'select',
        '#default_value' => is_numeric($field['tid']) ? $field['tid'] : 0,
        '#options' => $options_term,
        '#description' => t('If any term is selected here, only child terms of the selected are going to be shown in the field. Otherwise the whole vocabulary selected above'),
      );

      $form['vocabulary']['depth'] = array(
        '#type' => 'textfield',
        '#title' => t('Depth of taxonomy tree'),
        '#default_value' => is_numeric($field['depth']) ? $field['depth'] : '',
        '#description' => t('Leave this field blank to show the whole hierarchy. By setting a value, the depth of the hierarchy shown can be limited'),
      );
      
      $form['vocabulary']['show_depth'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Indent child terms with \' - \' signs'),
        '#default_value' => is_numeric($field['show_depth']) ? $field['show_depth'] : 1,
        '#description' => t('This option is only relevant for hierarchical vocabularies. If this option is checked, the hierarchy gets visualized by indenting child terms, otherwise it\'s a flat list'),
      );
      return $form;   
    
    case 'save':
      return array('save_term_node', 'vid', 'tid', 'depth', 'show_depth');
    
    case 'database columns':
      return array(
        'value' => array('type' => 'int', 'not null' => FALSE, 'sortable' => FALSE),
      );
  }
}

/**
 * Implementation of hook_field().
 */
function content_taxonomy_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {      
    case 'presave':
      if ($field['save_term_node']) {
        global $content_taxonomy_array_cleared;
        if (!is_array($content_taxonomy_array_cleared) || !$content_taxonomy_array_cleared[$node->nid]) {
          taxonomy_node_delete_revision($node);
          unset($node->taxonomy);
          $content_taxonomy_array_cleared[$node->nid] = true;
        }
      
        foreach ($items as $key => $entry) {
          if ($entry['value']) {
            $node->taxonomy[$entry['value']] = $entry['value'];
          }
        }
      }
      break;
  }
}


/**
 * Implementation of hook_field_formatter_info().
 */
function content_taxonomy_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('As Text'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
    'link' => array(
      'label' => t('As Link'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}


/**
 * Theme function for 'default' text field formatter.
 */
function theme_content_taxonomy_formatter_default($element) {
  $term = taxonomy_get_term($element['#item']['value']);
  return check_plain($term->name);
}

/**
 * Theme function for 'link' text field formatter.
 */
function theme_content_taxonomy_formatter_link($element) {
  $term = taxonomy_get_term($element['#item']['value']);
  return l($term->name, taxonomy_term_path($term), array('rel' => 'tag', 'title' => $term->description));
}

/**
 * Implementation of hook_content_is_empty().
 */
function content_taxonomy_content_is_empty($item, $field) {
  if (empty($item['value']) || $item['value'] == 0) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Called by content_allowed_values to create the $options array for the content_taxonomy_options
 */
function content_taxonomy_allowed_values($field) {
  $options = array();
  
  //for opt groups call different function
  if (isset($field['widget']['group_tid']) && $field['widget']['group_tid'] != 0) {
    return content_taxonomy_allowed_values_groups($field);
  }
  
  $depth = (is_numeric($field['depth'])) ? $field['depth'] : NULL;

  $tree = taxonomy_get_tree($field['vid'], $field['tid'], -1, $depth);
  
  if (is_array($tree)) {
    foreach ($tree as $term) {
      if ($field['show_depth']) {
        $value = str_repeat(' - ', $term->depth) . $term->name;
      }
      else {
        $value = $term->name;
      }
      $options[$term->tid] = $value;
    }
  }
  
  return $options;
}

/** 
 * Creating Opt Groups for content_taxonomy_options
 */
function content_taxonomy_allowed_values_groups($field) {
  $options = array();
  $parent = $field['tid'];
  $group_parent = $field['widget']['group_tid'];
  
  //if children in no group
  $default_terms = taxonomy_get_children($parent);
  foreach ($default_terms as $default_term) {
    $options[$default_term->tid] = $default_term->name;
  }
  
  foreach (taxonomy_get_children($group_parent) as $group) {
    foreach (taxonomy_get_children($group->tid) as $term) {
      $options[$group->name][$term->tid] = $term->name;
      unset($options[$term->tid]);
    }
  }

  return $options;
}

?>
