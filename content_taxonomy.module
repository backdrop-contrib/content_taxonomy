<?php

// $Id$

/**
 * @file
 * Defines a field type for referencing a taxonomy term.
 **/

/**
 * Implementation of hook_help().
 **/
function content_taxonomy_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Defines a field type for referencing a taxonomy term. <em>Note: Requires content.module.</em>');
  }
}

/**
 * Implementation of hook_theme().
 */
function content_taxonomy_theme() {
  return array(
    'content_taxonomy_formatter_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'content_taxonomy_formatter_link' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implementation of hook_field_info().
 */
function content_taxonomy_field_info() {
  return array(
    'content_taxonomy' => array(
      'label' => t('Content Taxonomy Fields'),
      'description' => t('Stores terms for the nodes in the database.'),
      'callbacks' => array(
        'tables' => CONTENT_CALLBACK_DEFAULT,
        'arguments' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of hook_field_settings().
 */
function content_taxonomy_field_settings($op, $field) {
  switch ($op) {
    case 'form':
      $form = array();
            
      $form['save_term_node'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Save values additionally in the term_node table.'),
        '#default_value' => isset($field['save_term_node']) ? $field['save_term_node'] : 0,
        '#description' => t('If this option is set, saving of terms is additionally handled by the taxonomy module. So saved terms from Content Taxonomy fields will appear as any other terms saved by the core taxonomy module. Set this option if you are using any other taxonomy application, like tagadelic. Otherwise terms are only saved in the cck tables and can only be accessed via the node or a view'), 
      );
      
      $form['vocabulary'] = array(
        '#type' => 'fieldset',
        '#title' => t('Specify terms to show'),
        '#collapsible' => TRUE,
      );
      
      $options_term = array();
      $options_voc = array();
      $options_term[0] = '---';
      foreach (taxonomy_get_vocabularies() as $voc) {
        $options_voc[$voc->vid] = $voc->name;
        foreach (taxonomy_get_tree($voc->vid) as $term) {
          $options_term[$voc->name][$term->tid] = str_repeat('- ', $term->depth) . $term->name;
        }
      }
      
      $form['vocabulary']['vid'] = array(
        '#title' => t('Vocabulary'),
        '#type' => 'select',
        '#default_value' => isset($field['vid']) ? $field['vid'] : 0,
        '#options' => $options_voc,
      );
      
      $form['vocabulary']['tid'] = array(
        '#title' => t('Terms'),
        '#type' => 'select',
        '#default_value' => isset($field['tid']) ? $field['tid'] : 0,
        '#options' => $options_term,
        '#description' => t('If any term is selected here, only child terms of the selected are going to be shown in the field. Otherwise the whole vocabulary selected above'),
      );

      $form['vocabulary']['depth'] = array(
        '#type' => 'textfield',
        '#title' => t('Depth of taxonomy tree'),
        '#default_value' => isset($field['depth']) ? $field['depth'] : 1,
        '#description' => t('leave blank for unlimited depth'),
      );
      
      $form['vocabulary']['show_depth'] = array(
        '#type' => 'checkbox', 
        '#title' => t('Indent child terms with \' - \' signs'),
        '#default_value' => isset($field['show_depth']) ? $field['show_depth'] : 1,
      );
      return $form;   
    
    case 'save':
      return array('save_term_node', 'vid', 'tid', 'depth', 'show_depth');
    
    case 'database columns':
      return array(
        'value' => array('type' => 'int', 'not null' => FALSE, 'sortable' => FALSE),
      );
  }
}

/**
 * Implementation of hook_field().
 */
function content_taxonomy_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {      
    case 'presave':
      if ($field['save_term_node']) {
        global $content_taxonomy_array_cleared;
        if (!is_array($content_taxonomy_array_cleared) || !$content_taxonomy_array_cleared[$node->nid]) {
          taxonomy_node_delete_revision($node);
          unset($node->taxonomy);
          $content_taxonomy_array_cleared[$node->nid] = true;
        }
      
        foreach ($items as $key => $entry) {
          if ($entry['value']) {
            $node->taxonomy[$entry['value']] = $entry['value'];
          }
        }
      }
      break;
  }
}


/**
 * Implementation of hook_field_formatter_info().
 */
function content_taxonomy_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('As Text'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
    'link' => array(
      'label' => t('As Link'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}


/**
 * Theme function for 'default' text field formatter.
 */
function theme_content_taxonomy_formatter_default($element) {
  $term = taxonomy_get_term($element['#item']['value']);
  return check_plain($term->name);
}

/**
 * Theme function for 'link' text field formatter.
 */
function theme_content_taxonomy_formatter_link($element) {
  $term = taxonomy_get_term($element['#item']['value']);
  return l($term->name, taxonomy_term_path($term), array('rel' => 'tag', 'title' => $term->description));
}


function content_taxonomy_allowed_values($field) {
  $options = array();
  
  if (isset($field['widget']['group_tid']) && $field['widget']['group_tid'] != 0) {
    return content_taxonomy_allowed_values_groups($field);
  }
  
  $depth = (isset($field['depth']) && is_numeric($field['depth'])) ? $field['depth'] : NULL;
  
  if ($depth == 1) {
    $tree = taxonomy_get_children($field['tid'], $field['vid']);
  }
  else {
    $tree = taxonomy_get_tree($field['vid'], $field['tid'], -1, $depth);
  }
  
  if ($tree) {
    foreach ($tree as $term) {
      if ($field['show_depth']) {
        $value = str_repeat(' - ', $term->depth) . $term->name;
      }
      else {
        $value = $term->name;
      }
      $options[$term->tid] = $value;
    }
  }
  
  return $options;
}


function content_taxonomy_allowed_values_groups($field) {
  $options = array();
  $parent = $field['tid'];
  $group_parent = $field['widget']['group_tid'];
  
  //if children in no group
  $default_terms = taxonomy_get_children($parent);
  foreach ($default_terms as $default_term) {
    $options[$default_term->tid] = $default_term->name;
  }
  
  foreach (taxonomy_get_children($group_parent) as $group) {
    foreach (taxonomy_get_children($group->tid) as $term) {
      $options[$group->name][$term->tid] = $term->name;
      unset($options[$term->tid]);
    }
  }

  return $options;
}

?>
