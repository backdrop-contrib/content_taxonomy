<?php
// $Id$

/**
 * @file
 * Defines a widget type for content_taxonomy with autocomplete
 **/

/**
 * Implementation of hook_help().
 **/
function content_taxonomy_autocomplete_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Defines a widget type for content_taxonomy with autocomplete. <em>Note: Requires content.module.</em>');
  }
}


/**
 * Implementation of hook_theme().
 */
function content_taxonomy_autocomplete_theme() {
  return array(
    'content_taxonomy_autocomplete' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implementation of hook_menu
 */
function content_taxonomy_autocomplete_menu() {
  $items['content_taxonomy/autocomplete'] = array(
    'title' => 'Autocomplete',
    'page callback' => 'content_taxonomy_autocomplete_load',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  return $items;
}

/**
 * Implementation of hook_widget_info().
 */
function content_taxonomy_autocomplete_widget_info() {
  return array(
    'content_taxonomy_autocomplete' => array(
      'label' => t('Autocomplete'),
      'field types' => array('content_taxonomy'),
      'multiple values' => CONTENT_HANDLE_MODULE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
  return $items;
}

/**
 * Implementation of hook_widget_settings
 */
function content_taxonomy_autocomplete_widget_settings($op, $widget) {
  switch ($op) {
    case 'form':
      $form = array();
      
      $form['autocomplete'] = array(
        '#type' => 'fieldset',
        '#title' => t('Autocomplete'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      );
      $form['autocomplete']['new_terms'] = array(
        '#type' => 'radios',
        '#title' => t('New terms from to user:'),
        '#default_value' => isset($widget['new_terms']) ? $widget['new_terms'] : 'insert',
        '#options' => array('insert' => t('Allow and insert new terms into the taxonomy tree'),
                            'deny' => t('Deny any new terms'),
                            ),
      );
      $options_term = array();
      $options_term[0] = '---';
      foreach (taxonomy_get_vocabularies() as $voc) {
        foreach (taxonomy_get_tree($voc->vid) as $term) {
          $options_term[$voc->name][$term->tid] = str_repeat('- ', $term->depth) . $term->name;
        }
      }
      $form['autocomplete']['extra_parent'] = array(
        '#type' => 'select', 
        '#title' => t('Extra Parent for new terms'), 
        '#options' => $options_term, 
        '#description' => t('This setting is only relevant if you have set "Allow and insert new terms into the taxonomy tree". If you select any term here, new terms will get children of the selected one, otherwise new terms get children of the parent term selected in the data settings'),
      );
      
      return $form;

    case 'save':
      return array('new_terms', 'extra_parent');
  }
}

/**
 * Implementation of FAPI hook_elements().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 *
 * Autocomplete_path is not used by text_widget but other widgets can use it
 * (see nodereference and userreference).
 */
function content_taxonomy_autocomplete_elements() {
  return array(
    'content_taxonomy_autocomplete' => array(
      '#input' => TRUE,
      '#columns' => array('value'), 
      '#delta' => 0,
      '#element_validate' => array('content_taxonomy_autocomplete_validate'),
      '#process' => array('content_taxonomy_autocomplete_process'),
      '#autocomplete_path' => FALSE,
      ),
    );
}

/**
 * Implementation of hook_widget().
 */
function content_taxonomy_autocomplete_widget(&$form, &$form_state, $field, $items, $delta = NULL) {
  $element = array(
    '#type' => 'content_taxonomy_autocomplete',
    '#default_value' => isset($items) ? $items : NULL,
  );
  return $element;
}


/**
 * Process an individual element.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 */
function content_taxonomy_autocomplete_process($element, $edit, $form_state, $form) {
  $field_name = $element['#field_name'];
  $field = $form['#field_info'][$field_name];
  $field_key  = $element['#columns'][0];
  
  if (!$form_state['submitted'] || $form_state['clicked_button']['#value'] == t('Preview')) {
    $element['#value'] = content_taxonomy_autocomplete_data2form($element, $element['#value'], $field);
  }

  $element[$field_key] = array(
    '#type' => 'textfield',
    '#default_value' => isset($element['#value']) ? $element['#value'] : '',
    '#autocomplete_path' => 'content_taxonomy/autocomplete/'. $element['#field_name'],
    '#field_name' => $element['#field_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
    '#title' => $element['#title'],
    '#required' => $element['#required'],
    '#description' => $element['#description'],
  );
  return $element;
}

function content_taxonomy_autocomplete_validate($element, &$form_state) {
  $field_name = $element['#field_name'];
  $field = content_fields($field_name);
  $field_key  = $element['#columns'][0];
  $value = $form_state['values'][$element['#field_name']][$field_key];
 
  $extracted_ids = content_taxonomy_autocomplete_tags_get_tids($value, $field['vid'], $field['tid'], $field['widget']['extra_parent']);
  
  if (!$field['multiple'] && count(content_taxonomy_autocomplete_split_tags($value, $field['vid'])) > 1) {
    form_set_error($field['field_name'] .'][value', t('You can provide only one value'));
    return;
  }
  if ($field['widget']['new_terms'] == 'deny') {
    if (is_array($extracted_ids['non_existing_terms'])) {
      form_set_error($field['field_name'] .'][value', t('New tags are not allowed'));
      return;
    }
  }
  
  $values = content_taxonomy_autocomplete_form2data($extracted_ids, $field, $element);
  form_set_value($element, $values, $form_state);
}

function content_taxonomy_autocomplete_form2data($extracted_ids, $field, $element) {
  $existing_tids = is_array($extracted_ids['existing_tids']) ? $extracted_ids['existing_tids'] : array();
  $new_tids = array();
  if (is_array($extracted_ids['non_existing_terms'])) {
    if ($field['widget']['extra_parent']) {
      $new_tids = content_taxonomy_autocomplete_insert_tags($extracted_ids['non_existing_terms'], $field['widget']['extra_parent']);
    } 
    else if ($tid && $depth == 1) {
     $new_tids = content_taxonomy_autocomplete_insert_tags($extracted_ids['non_existing_terms'], $field['tid']);
    }
    else {
      $new_tids = content_taxonomy_autocomplete_insert_tags($extracted_ids['non_existing_terms']);          
    }
  }
  return content_transpose_array_rows_cols(array($element['#columns'][0] => array_merge($existing_tids, $new_tids)));

}

function content_taxonomy_autocomplete_data2form($element, $values, $field) {
  $terms = array();
  foreach ($values as $delta => $entry) {
    $terms[] = taxonomy_get_term($entry['value']);
  }
  return content_taxonomy_autocomplete_merge_tags($terms, $field['vid']);
}

/**
 * Retrieve a pipe delimited string of autocomplete suggestions
 * 
 * @param String Fieldname
 * @param Integer TID of a parent (optional)
 * @param BOOLEAN whether a multiple field or not
 * @param STRING typed input
 */
function content_taxonomy_autocomplete_load($field_name, $string = '') {
   // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  // This regexp allows the following types of user input:
  // this, "somecmpany, llc", "and ""this"" w,o.rks", foo bar
  $content_type_info = _content_type_info();
  $vid = $content_type_info['fields'][$field_name]['vid'];
  if ($content_type_info['fields'][$field_name]['tid']) {
    $tid = $content_type_info['fields'][$field_name]['tid'];
  }
  elseif ($content_type_info['fields'][$field_name]['parent']) {
    $tid = $content_type_info['fields'][$field_name]['parent'];
  }
  
  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $array = drupal_explode_tags($string);

  // Fetch last tag
  $last_string = trim(array_pop($array));
  $matches = array();
  if ($last_string != '') {
    if ($tid) {
      $result = db_query_range(db_rewrite_sql("SELECT t.name FROM {term_data} t 
        LEFT JOIN {term_synonym} s ON t.tid = s.tid
        INNER JOIN {term_hierarchy} h ON  t.tid = h.tid
        WHERE h.parent = %d 
        AND (LOWER(t.name) LIKE LOWER('%%%s%%') OR LOWER(s.name) LIKE LOWER('%%%s%%'))", 't', 'tid'),
        $tid,$last_string,$last_string,0,10);
    }
    else {
      $result = db_query_range(db_rewrite_sql("SELECT t.name FROM {term_data} t 
        LEFT JOIN {term_synonym} s ON t.tid = s.tid
        WHERE t.vid = %d 
        AND (LOWER(t.name) LIKE LOWER('%%%s%%') OR LOWER(s.name) LIKE LOWER('%%%s%%'))", 't', 'tid'),
        $vid, $last_string, $last_string, 0, 10);
    }

    $prefix = count($array) ? implode(', ', $array) .', ' : '';

    while ($tag = db_fetch_object($result)) {
      $n = $tag->name;
      // Commas and quotes in terms are special cases, so encode 'em.
      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {
        $n = '"'. str_replace('"', '""', $tag->name) .'"';
      }
      $matches[$prefix . $n] = check_plain($tag->name);
    }
  }

  drupal_json($matches);
}

/**
 * Get TIDs for freetagging tags
 *  Free tagging vocabularies do not send their tids in the form,
 *  so we'll detect them here and process them independently.
 * @param $typed_input A string containing all comma separated tags. As the user typed it.
 */
function content_taxonomy_autocomplete_tags_get_tids($typed_input, $vid, $parent = 0, $extra_parent = 0) {
  // This regexp allows the following types of user input:
  // this, "somecmpany, llc", "and ""this"" w,o.rks", foo bar
  $typed_terms = content_taxonomy_autocomplete_split_tags($typed_input);

  foreach ($typed_terms as $typed_term) {
    // If a user has escaped a term (to demonstrate that it is a group,
    // or includes a comma or quote character), we remove the escape
    // formatting so to save the term into the DB as the user intends.
    $typed_term = str_replace('""', '"', preg_replace('/^"(.*)"$/', '\1', $typed_term));
    $typed_term = trim($typed_term);
    if ($typed_term == "") { continue; }

    // See if the term exists in the chosen vocabulary
    // and return the tid, otherwise, add a new record.
    $possibilities = taxonomy_get_term_by_name($typed_term);

    $typed_term_tid = NULL; // tid match if any.
    foreach ($possibilities as $possibility) {
      if ($possibility->vid == $vid) {
        if ($parent) {
          $parents = array();
          $parents = taxonomy_get_parents($possibility->tid);
          if (in_array($parent, array_keys($parents)) || in_array($extra_parent, array_keys($parents))) {
            $result['existing_tids'][$possibility->tid] = $possibility->tid;
            $typed_term_tid = $possibility->tid;  
          }
        }
        else {
          $result['existing_tids'][$possibility->tid] = $possibility->tid;
          $typed_term_tid = $possibility->tid;
        }
      }
    }

    if (!$typed_term_tid) {
      $result['non_existing_terms'][] = array(
        'name' => $typed_term,
        'vid' => $vid,
      );
    }
  }

  return $result;
}

/**
 * Insert new tags
 * @param $nid the node id
 * @param $terms an array of all <strong>nonexisting</strong> terms.
 * @return an array of newly inserted term ids
 */
function content_taxonomy_autocomplete_insert_tags($terms, $parent = NULL) {
  foreach ($terms as $term) {
    $edit = array('vid' => $term['vid'], 'name' => $term['name']);
    if ($parent) $edit['parent'] = $parent;
    $status = taxonomy_save_term($edit);
    $saved_terms[$edit['tid']] = $edit['tid'];
  }
  return $saved_terms;
}

/**
 * Helper function to split the tags
 */
function content_taxonomy_autocomplete_split_tags($typed_input) {
  $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';
  preg_match_all($regexp, $typed_input, $matches);
  return $matches[1];
}

/**
 * Helper function to merge the tags, to prefill the fields when editing a node.
 */
function content_taxonomy_autocomplete_merge_tags($terms, $vid) {
  $typed_terms = array();
  if (!empty($terms)) {
    foreach ($terms as $term) {
      // Extract terms belonging to the vocabulary in question.
      if ($term->vid == $vid) {
        //if ($tid && in_array($term->tid,drupal_map_assoc(array_keys((taxonomy_get_children($tid,$vid)))))) {
          // Commas and quotes in terms are special cases, so encode 'em.
          if (preg_match('/,/', $term->name) || preg_match('/"/', $term->name)) {
            $term->name = '"'.preg_replace('/"/', '""', $term->name).'"';
          }
          $typed_terms[] = $term->name;
       // }
      }
    }
  }

  return implode(', ', $typed_terms);
}

function theme_content_taxonomy_autocomplete($element) {
  return $element['#children'];
}

?>
